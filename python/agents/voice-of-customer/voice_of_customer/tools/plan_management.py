"""Tools that allow the supervisor agent to manage its planner to-do list."""

from __future__ import annotations

from typing import Any, Tuple

from google.adk.tools import ToolContext

from ..shared.plan import (
    PLAN_STATE_KEY,
    PlanManager,
    PlanParsingError,
    TaskNotFoundError,
)


def _task_sort_key(task: "PlannerTaskLike") -> Tuple[int, Any]:
    """Returns a tuple used to order tasks by execution priority."""

    try:
        return (0, int(task.execution_order))
    except (TypeError, ValueError):  # pragma: no cover - defensive
        return (1, str(task.execution_order))


class PlannerTaskLike:
    """Protocol-lite helper for typing without importing PlannerTask."""

    execution_order: str
    task_description: str
    agent_name: str
    task_completed: bool


def store_supervisor_plan(plan: str, tool_context: ToolContext) -> dict[str, Any]:
    """Stores the planner output in the session state.

    Args:
        plan: JSON string generated by the planner agent.
        tool_context: The ADK tool context.

    Returns:
        A dictionary with metadata describing the stored plan.
    """

    manager = PlanManager(tool_context.state)

    try:
        parsed_plan = manager.set_plan_from_text(plan)
    except PlanParsingError as exc:
        return {
            "status": "error",
            "error": "plan_parsing_error",
            "message": (
                "Não foi possível interpretar o plano fornecido pelo planner. "
                "Solicite um novo plano antes de prosseguir."
            ),
            "detail": str(exc),
        }

    summary = manager.summary()
    return {
        "status": "stored",
        "state_key": PLAN_STATE_KEY,
        "total_tasks": summary.total_tasks,
        "pending_tasks": summary.remaining_tasks,
        "total_stages": summary.total_stages,
        "message": "Plano registrado no estado do supervisor.",
        "plan_preview": manager.plan_as_dict(),
        "raw_payload_length": len(plan),
        "stages": len(parsed_plan),
        "has_plan": bool(parsed_plan),
    }


def mark_supervisor_task_completed(
    execution_order: str, tool_context: ToolContext
) -> dict[str, Any]:
    """Marks the task identified by ``execution_order`` as completed."""

    manager = PlanManager(tool_context.state)
    try:
        task = manager.mark_task_completed(execution_order)
    except PlanParsingError as exc:
        return {
            "status": "error",
            "error": "plan_not_found",
            "message": (
                "Nenhum plano ativo foi encontrado. Acione o planner_agent antes de "
                "tentar concluir tarefas."
            ),
            "detail": str(exc),
        }
    except TaskNotFoundError as exc:
        return {
            "status": "error",
            "error": "task_not_found",
            "message": (
                "A tarefa informada não existe no plano atual. Confira a ordem de "
                "execução e tente novamente."
            ),
            "detail": str(exc),
        }

    summary = manager.summary()
    return {
        "status": "task_completed",
        "execution_order": task.execution_order,
        "task": task.to_dict(),
        "total_completed": summary.completed_tasks,
        "remaining_tasks": summary.remaining_tasks,
        "completed_stages": summary.completed_stages,
        "message": (
            "Tarefa atualizada com sucesso. Atualize o acompanhamento do plano no"
            " supervisor."
        ),
    }


def get_supervisor_plan_status(tool_context: ToolContext) -> dict[str, Any]:
    """Returns a summary of the current plan stored in the session state."""

    manager = PlanManager(tool_context.state)
    plan = manager.plan_as_dict()
    summary = manager.summary()
    return {
        "status": "plan_status",
        "plan": plan,
        "summary": summary.as_dict(),
        "markdown": manager.render_plan_markdown(),
        "has_plan": bool(plan),

    }


def ensure_next_task_ready(
    agent_name: str, tool_context: ToolContext
) -> dict[str, Any]:
    """Validates if the requested agent can take the next task in sequence."""

    manager = PlanManager(tool_context.state)
    plan = manager.load_plan()
    if not plan:
        return {
            "status": "error",
            "error": "plan_not_found",
            "message": (
                "Nenhum plano ativo foi encontrado. Acione o planner_agent antes de "
                "delegar tarefas a outros agentes."
            ),
        }

    pending_tasks = sorted(manager.pending_tasks(), key=_task_sort_key)
    if not pending_tasks:
        return {
            "status": "ready",
            "message": (
                "Não há tarefas pendentes. O agente pode ser acionado apenas se houver "
                "novo trabalho registrado pelo planner."
            ),
            "blocking_tasks": [],
        }

    matching_tasks = [
        task for task in pending_tasks if task.agent_name == agent_name
    ]
    if not matching_tasks:
        return {
            "status": "error",
            "error": "agent_not_in_plan",
            "message": (
                "O plano atual não possui tarefas pendentes para o agente informado. "
                "Confira o to-do e confirme qual agente deve ser acionado."
            ),
            "blocking_tasks": [task.to_dict() for task in pending_tasks],
        }

    target_task = matching_tasks[0]
    target_order = _task_sort_key(target_task)
    blocking_tasks = [
        task
        for task in pending_tasks
        if _task_sort_key(task) < target_order and not task.task_completed
    ]

    if not blocking_tasks:
        return {
            "status": "ready",
            "message": (
                "Tarefas do agente {agent} liberadas para execução.".format(
                    agent=agent_name
                )
            ),
            "next_task": target_task.to_dict(),
            "blocking_tasks": [],
            "remaining_tasks": len(pending_tasks),
        }

    supervisor_blockers = [
        task for task in blocking_tasks if task.agent_name == "supervisor_agent"
    ]
    data_collection_blockers = [
        task for task in blocking_tasks if task.agent_name == "data_collector_agent"
    ]

    if supervisor_blockers:
        return {
            "status": "blocked",
            "error": "prerequisites_incomplete",
            "message": (
                "Existem tarefas de esclarecimento pendentes (datas, canais ou objetivos) "
                "que precisam ser concluídas antes de acionar o agente {agent}."
            ).format(agent=agent_name),
            "blocking_tasks": [task.to_dict() for task in supervisor_blockers],
            "actionable_next_steps": [
                "Finalize as tarefas do supervisor relacionadas a datas, canais e objetivos.",
                "Confirme as informações com o solicitante e registre a conclusão no plano.",
            ],
        }

    if data_collection_blockers and agent_name in {
        "quanti_analyst_agent",
        "quali_analyst_agent",
    }:
        return {
            "status": "blocked",
            "error": "data_not_ready",
            "message": (
                "Os dados necessários ainda não foram coletados. Aguarde a conclusão das "
                "tarefas de coleta antes de prosseguir com {agent}."
            ).format(agent=agent_name),
            "blocking_tasks": [task.to_dict() for task in data_collection_blockers],
            "actionable_next_steps": [
                "Coordene a conclusão das tarefas de coleta de dados pendentes.",
                "Somente avance para análises após confirmar que os datasets foram registrados.",
            ],
        }

    return {
        "status": "blocked",
        "error": "out_of_order",
        "message": (
            "Há tarefas anteriores pendentes. Complete-as antes de acionar o agente {agent}."
        ).format(agent=agent_name),
        "blocking_tasks": [task.to_dict() for task in blocking_tasks],
        "actionable_next_steps": [
            "Siga a ordem definida pelo planner e marque as tarefas anteriores como concluídas.",
        ],
    }


def reset_supervisor_plan(tool_context: ToolContext) -> dict[str, Any]:
    """Clears the stored plan so a new request can start."""

    manager = PlanManager(tool_context.state)
    manager.reset_plan()
    return {
        "status": "reset",
        "message": (
            "Plano removido do estado. Acione o planner_agent antes de iniciar uma"
            " nova análise."
        ),
    }


def format_plan_tool_status(
    tool_name: str, response: dict[str, Any]
) -> str:
    """Formats tool responses so the supervisor can narrate them consistently.

    The Avenue Deep Dive supervisor must read back the outputs of plan
    management tools to the user using the pattern
    ``"[tool_name] tool reported: ..."``.  This helper extracts the most
    relevant fields from ``response`` to build that narration, falling back to a
    JSON representation when a more specific summary is not available.

    Args:
        tool_name: Name of the tool that produced ``response``.
        response: Dictionary returned by a plan management tool.

    Returns:
        A natural-language string ready to be surfaced to the user.
    """

    highlight_parts: list[str] = []

    message = response.get("message")
    if isinstance(message, str) and message:
        highlight_parts.append(message.strip())

    if response.get("status") == "error":
        detail = response.get("detail")
        if isinstance(detail, str) and detail:
            highlight_parts.append(f"Detalhe: {detail.strip()}")
        highlight_text = " ".join(part for part in highlight_parts if part)
        if not highlight_text:
            highlight_text = json.dumps(response, ensure_ascii=False)
        return f"{tool_name} tool reported: {highlight_text}"

    if tool_name == "store_supervisor_plan":
        total_tasks = response.get("total_tasks")
        pending_tasks = response.get("pending_tasks")
        total_stages = response.get("total_stages") or response.get("stages")
        if total_tasks is not None and pending_tasks is not None:
            highlight_parts.append(
                f"Total de tarefas registradas: {total_tasks}."
                f" Pendentes: {pending_tasks}."
            )
        if total_stages is not None:
            highlight_parts.append(f"Etapas no plano: {total_stages}.")
    elif tool_name == "mark_supervisor_task_completed":
        execution_order = response.get("execution_order")
        total_completed = response.get("total_completed")
        remaining_tasks = response.get("remaining_tasks")
        completed_stages = response.get("completed_stages")
        if execution_order is not None:
            highlight_parts.append(
                f"Tarefa {execution_order} marcada como concluída."
            )
        if total_completed is not None and remaining_tasks is not None:
            highlight_parts.append(
                f"Andamento: {total_completed} concluídas,"
                f" {remaining_tasks} pendentes."
            )
        if completed_stages is not None:
            highlight_parts.append(f"Etapas concluídas: {completed_stages}.")
    elif tool_name == "get_supervisor_plan_status":
        summary = response.get("summary")
        if isinstance(summary, dict):
            total_tasks = summary.get("total_tasks")
            completed_tasks = summary.get("completed_tasks")
            remaining_tasks = summary.get("remaining_tasks")
            total_stages = summary.get("total_stages")
            completed_stages = summary.get("completed_stages")
            if (
                total_tasks is not None
                and completed_tasks is not None
                and remaining_tasks is not None
            ):
                highlight_parts.append(
                    "Status atual: "
                    f"{completed_tasks}/{total_tasks} tarefas concluídas"
                    f" ({remaining_tasks} pendentes)."
                )
            if total_stages is not None and completed_stages is not None:
                highlight_parts.append(
                    f"Etapas concluídas: {completed_stages} de {total_stages}."
                )
        markdown = response.get("markdown")
        if isinstance(markdown, str) and markdown:
            highlight_parts.append(f"Resumo formatado:\n{markdown.strip()}")
    elif tool_name == "reset_supervisor_plan":
        # Message already covers the important status information.
        pass
    else:
        highlight_parts.append(json.dumps(response, ensure_ascii=False))

    highlight_text = " ".join(part.strip() for part in highlight_parts if part)
    if not highlight_text:
        highlight_text = json.dumps(response, ensure_ascii=False)
    return f"{tool_name} tool reported: {highlight_text}"


__all__ = [
    "PlanParsingError",
    "TaskNotFoundError",
    "ensure_next_task_ready",
    "get_supervisor_plan_status",
    "mark_supervisor_task_completed",
    "reset_supervisor_plan",
    "store_supervisor_plan",
]
