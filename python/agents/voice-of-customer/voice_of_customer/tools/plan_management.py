"""Tools that allow the supervisor agent to manage its planner to-do list."""

from __future__ import annotations

from typing import Any

from google.adk.tools import ToolContext

from ..shared.plan import (
    PLAN_STATE_KEY,
    PlanManager,
    PlanParsingError,
    TaskNotFoundError,
)


def store_supervisor_plan(plan: str, tool_context: ToolContext) -> dict[str, Any]:
    """Stores the planner output in the session state.

    Args:
        plan: JSON string generated by the planner agent.
        tool_context: The ADK tool context.

    Returns:
        A dictionary with metadata describing the stored plan.
    """

    manager = PlanManager(tool_context.state)

    try:
        parsed_plan = manager.set_plan_from_text(plan)
    except PlanParsingError as exc:
        return {
            "status": "error",
            "error": "plan_parsing_error",
            "message": (
                "Não foi possível interpretar o plano fornecido pelo planner. "
                "Solicite um novo plano antes de prosseguir."
            ),
            "detail": str(exc),
        }

    summary = manager.summary()
    return {
        "status": "stored",
        "state_key": PLAN_STATE_KEY,
        "total_tasks": summary.total_tasks,
        "pending_tasks": summary.remaining_tasks,
        "total_stages": summary.total_stages,
        "message": "Plano registrado no estado do supervisor.",
        "plan_preview": manager.plan_as_dict(),
        "raw_payload_length": len(plan),
        "stages": len(parsed_plan),
        "has_plan": bool(parsed_plan),
    }


def mark_supervisor_task_completed(
    execution_order: str, tool_context: ToolContext
) -> dict[str, Any]:
    """Marks the task identified by ``execution_order`` as completed."""

    manager = PlanManager(tool_context.state)

    try:
        task = manager.mark_task_completed(execution_order)
    except PlanParsingError as exc:
        return {
            "status": "error",
            "error": "plan_not_found",
            "message": (
                "Nenhum plano ativo foi encontrado. Acione o planner_agent antes de "
                "tentar concluir tarefas."
            ),
            "detail": str(exc),
        }
    except TaskNotFoundError as exc:
        return {
            "status": "error",
            "error": "task_not_found",
            "message": (
                "A tarefa informada não existe no plano atual. Confira a ordem de "
                "execução e tente novamente."
            ),
            "detail": str(exc),
        }

    summary = manager.summary()
    return {
        "status": "task_completed",
        "execution_order": task.execution_order,
        "task": task.to_dict(),
        "total_completed": summary.completed_tasks,
        "remaining_tasks": summary.remaining_tasks,
        "completed_stages": summary.completed_stages,
        "message": (
            "Tarefa atualizada com sucesso. Atualize o acompanhamento do plano no"
            " supervisor."
        ),
    }


def get_supervisor_plan_status(tool_context: ToolContext) -> dict[str, Any]:
    """Returns a summary of the current plan stored in the session state."""

    manager = PlanManager(tool_context.state)
    plan = manager.plan_as_dict()
    summary = manager.summary()
    return {
        "status": "plan_status",
        "plan": plan,
        "summary": summary.as_dict(),
        "markdown": manager.render_plan_markdown(),
        "has_plan": bool(plan),
    }


def reset_supervisor_plan(tool_context: ToolContext) -> dict[str, Any]:
    """Clears the stored plan so a new request can start."""

    manager = PlanManager(tool_context.state)
    manager.reset_plan()
    return {
        "status": "reset",
        "message": (
            "Plano removido do estado. Acione o planner_agent antes de iniciar uma"
            " nova análise."
        ),
    }


__all__ = [
    "PlanParsingError",
    "TaskNotFoundError",
    "get_supervisor_plan_status",
    "mark_supervisor_task_completed",
    "reset_supervisor_plan",
    "store_supervisor_plan",
]
