"""Tools that allow the supervisor agent to manage its planner to-do list."""

from __future__ import annotations

import json
from typing import Any

from google.adk.tools import ToolContext

from ..shared.plan import (
    PLAN_STATE_KEY,
    PlanManager,
    PlanParsingError,
    TaskNotFoundError,
)


def store_supervisor_plan(plan: str, tool_context: ToolContext) -> dict[str, Any]:
    """Stores the planner output in the session state.

    Args:
        plan: JSON string generated by the planner agent.
        tool_context: The ADK tool context.

    Returns:
        A dictionary with metadata describing the stored plan.
    """

    manager = PlanManager(tool_context.state)

    try:
        parsed_plan = manager.set_plan_from_text(plan)
    except PlanParsingError as exc:
        return {
            "status": "error",
            "error": "plan_parsing_error",
            "message": (
                "Não foi possível interpretar o plano fornecido pelo planner. "
                "Solicite um novo plano antes de prosseguir."
            ),
            "detail": str(exc),
        }

    summary = manager.summary()
    return {
        "status": "stored",
        "state_key": PLAN_STATE_KEY,
        "total_tasks": summary.total_tasks,
        "pending_tasks": summary.remaining_tasks,
        "total_stages": summary.total_stages,
        "message": "Plano registrado no estado do supervisor.",
        "plan_preview": manager.plan_as_dict(),
        "raw_payload_length": len(plan),
        "stages": len(parsed_plan),
        "has_plan": bool(parsed_plan),
    }


def mark_supervisor_task_completed(
    execution_order: str, tool_context: ToolContext
) -> dict[str, Any]:
    """Marks the task identified by ``execution_order`` as completed."""

    manager = PlanManager(tool_context.state)
    try:
        task = manager.mark_task_completed(execution_order)
    except PlanParsingError as exc:
        return {
            "status": "error",
            "error": "plan_not_found",
            "message": (
                "Nenhum plano ativo foi encontrado. Acione o planner_agent antes de "
                "tentar concluir tarefas."
            ),
            "detail": str(exc),
        }
    except TaskNotFoundError as exc:
        return {
            "status": "error",
            "error": "task_not_found",
            "message": (
                "A tarefa informada não existe no plano atual. Confira a ordem de "
                "execução e tente novamente."
            ),
            "detail": str(exc),
        }

    summary = manager.summary()
    return {
        "status": "task_completed",
        "execution_order": task.execution_order,
        "task": task.to_dict(),
        "total_completed": summary.completed_tasks,
        "remaining_tasks": summary.remaining_tasks,
        "completed_stages": summary.completed_stages,
        "message": (
            "Tarefa atualizada com sucesso. Atualize o acompanhamento do plano no"
            " supervisor."
        ),
    }


def get_supervisor_plan_status(tool_context: ToolContext) -> dict[str, Any]:
    """Returns a summary of the current plan stored in the session state."""

    manager = PlanManager(tool_context.state)
    plan = manager.plan_as_dict()
    summary = manager.summary()
    return {
        "status": "plan_status",
        "plan": plan,
        "summary": summary.as_dict(),
        "markdown": manager.render_plan_markdown(),
        "has_plan": bool(plan),

    }


def reset_supervisor_plan(tool_context: ToolContext) -> dict[str, Any]:
    """Clears the stored plan so a new request can start."""

    manager = PlanManager(tool_context.state)
    manager.reset_plan()
    return {
        "status": "reset",
        "message": (
            "Plano removido do estado. Acione o planner_agent antes de iniciar uma"
            " nova análise."
        ),
    }


def format_plan_tool_status(
    tool_name: str, response: dict[str, Any]
) -> str:
    """Formats tool responses so the supervisor can narrate them consistently.

    The Avenue Deep Dive supervisor must read back the outputs of plan
    management tools to the user using the pattern
    ``"[tool_name] tool reported: ..."``.  This helper extracts the most
    relevant fields from ``response`` to build that narration, falling back to a
    JSON representation when a more specific summary is not available.

    Args:
        tool_name: Name of the tool that produced ``response``.
        response: Dictionary returned by a plan management tool.

    Returns:
        A natural-language string ready to be surfaced to the user.
    """

    highlight_parts: list[str] = []

    message = response.get("message")
    if isinstance(message, str) and message:
        highlight_parts.append(message.strip())

    if response.get("status") == "error":
        detail = response.get("detail")
        if isinstance(detail, str) and detail:
            highlight_parts.append(f"Detalhe: {detail.strip()}")
        highlight_text = " ".join(part for part in highlight_parts if part)
        if not highlight_text:
            highlight_text = json.dumps(response, ensure_ascii=False)
        return f"{tool_name} tool reported: {highlight_text}"

    if tool_name == "store_supervisor_plan":
        total_tasks = response.get("total_tasks")
        pending_tasks = response.get("pending_tasks")
        total_stages = response.get("total_stages") or response.get("stages")
        if total_tasks is not None and pending_tasks is not None:
            highlight_parts.append(
                f"Total de tarefas registradas: {total_tasks}."
                f" Pendentes: {pending_tasks}."
            )
        if total_stages is not None:
            highlight_parts.append(f"Etapas no plano: {total_stages}.")
    elif tool_name == "mark_supervisor_task_completed":
        execution_order = response.get("execution_order")
        total_completed = response.get("total_completed")
        remaining_tasks = response.get("remaining_tasks")
        completed_stages = response.get("completed_stages")
        if execution_order is not None:
            highlight_parts.append(
                f"Tarefa {execution_order} marcada como concluída."
            )
        if total_completed is not None and remaining_tasks is not None:
            highlight_parts.append(
                f"Andamento: {total_completed} concluídas,"
                f" {remaining_tasks} pendentes."
            )
        if completed_stages is not None:
            highlight_parts.append(f"Etapas concluídas: {completed_stages}.")
    elif tool_name == "get_supervisor_plan_status":
        summary = response.get("summary")
        if isinstance(summary, dict):
            total_tasks = summary.get("total_tasks")
            completed_tasks = summary.get("completed_tasks")
            remaining_tasks = summary.get("remaining_tasks")
            total_stages = summary.get("total_stages")
            completed_stages = summary.get("completed_stages")
            if (
                total_tasks is not None
                and completed_tasks is not None
                and remaining_tasks is not None
            ):
                highlight_parts.append(
                    "Status atual: "
                    f"{completed_tasks}/{total_tasks} tarefas concluídas"
                    f" ({remaining_tasks} pendentes)."
                )
            if total_stages is not None and completed_stages is not None:
                highlight_parts.append(
                    f"Etapas concluídas: {completed_stages} de {total_stages}."
                )
        markdown = response.get("markdown")
        if isinstance(markdown, str) and markdown:
            highlight_parts.append(f"Resumo formatado:\n{markdown.strip()}")
    elif tool_name == "reset_supervisor_plan":
        # Message already covers the important status information.
        pass
    else:
        highlight_parts.append(json.dumps(response, ensure_ascii=False))

    highlight_text = " ".join(part.strip() for part in highlight_parts if part)
    if not highlight_text:
        highlight_text = json.dumps(response, ensure_ascii=False)
    return f"{tool_name} tool reported: {highlight_text}"


__all__ = [
    "PlanParsingError",
    "TaskNotFoundError",
    "format_plan_tool_status",
    "get_supervisor_plan_status",
    "mark_supervisor_task_completed",
    "reset_supervisor_plan",
    "store_supervisor_plan",
]
